from marshmallow import Schema, fields


# Schemas is needed to define data schemas for validation, serialization, and deserialization purposes

# --------------------------------------------------------------
# Serialization -> Python object -> JSON # (output to user)
# Deserialization -> JSON -> Python object (input from user)

# Define fields and how they are going to behave in case of input / output
# We want to create schema for each type of data we are going to receive either as input or update

# Item: name, price, id, PlainStore (store_id, store_name)
# store: name, id, Items[] = PlainItem[] (Item_id, Item_name, Item_price)
# This is done to prevent circular dependencies
# --------------------------------------------------------------

# POST /item  -> check name, price (if missing, we cannot create an item)
# GET /item ->  return name, price and item_id
# Deserialization: name, price
# Serialization: name, price, item_id
class PlainItemSchema(Schema): # This class will be needed to create an item only, so it doesnt relate to a store at all

    # Serialization: id will be converted to json, at Deserialization will not be checked because the user doesnt give us the item id
    id = fields.Int(dump_only=True) # dump_only = True -> Serialization only (Generated by us)
    name = fields.Str(required = True) # We require the name and price to be present in Deserialization
    price = fields.Float(required = True) 


# POST /store -> validate name
# Serialization: name, store_id
# Deserialization: name
class PlainStoreSchema(Schema):
    name = fields.Str(required = True) # name must be required at deserialization
    id = fields.Int(dump_only=True) # Serialization only

# Serialization: name
# Deserialization: name, tag_id
class PlainTagSchema(Schema): # what is needed to create a plain tag?
    
    name = fields.Str(required=True)
    id = fields.Int(dump_only=True)
    

# PUT request to /item/<item_id> ->  validate name, price, store_id (not a must)
# Deserialization: name, price, store_id
# if the item exists, we take only the name and the price. if the item doesnt exist we take all the arguments
class ItemUpdateSchema(Schema):

    name = fields.Str() 
    price = fields.Float()
    store_id = fields.Int()


# Deserialization: item_name, item_price, store_id (will be not serialized back)
# Serialization: item_name, item_price, item_id, PlainStoreSchema (name, store_id), PlainTagSchema[] -> (TAG_NAME, TAG_ID)
class ItemSchema(PlainItemSchema):
    # ItemSchema will have item_id, name and price. And will be able to get a store_id also to that item

    store_id = fields.Int(required=True, load_only=True) # load_only=True -> only deserialize 
    store = fields.Nested(PlainStoreSchema(), dump_only = True) # item will have 1 store
    # we dont need to return the store_id because it is returned at the store nested store schema
    
    tags = fields.List(fields.Nested(PlainTagSchema), dump_only = True) # a list of tags
    
# Deserialization: store_name
# Serialization: store_name, store_id, PlainItemSchema[] -> (item_name, item_price, item_id) , PlainitemSchema[] -> (tag_name, tag_id)
class StoreSchema(PlainStoreSchema): 
    
    # store will have a store_id and a name. And will be able to return a list of items, and a list of tags
    items = fields.List(fields.Nested(PlainItemSchema()), dump_only=True)
    tags = fields.List(fields.Nested(PlainTagSchema()), dump_only=True)


# Deserialization: tag_name, store_id
# Serialization: tag_name, tag_id, PlainStoreSchema (name, store_id), PlainItemSchema[] -> (ITEM_NAME, ITEM_ID, ITEM_PRICE)
class TagSchema(PlainTagSchema): 

    store_id = fields.Int(load_only=True) 
    store = fields.Nested(PlainStoreSchema(), dump_only=True)
    # we dont need to return the store_id because the store will return the store_id as a nested StoreSchema

    items = fields.List(fields.Nested(PlainTagSchema), dump_only=True) # a list of items


# Deserialization: message, PlainItemSchema, PlainTagSchema
# Serialization: message, PlainItemSchema, PlainTagSchema
class TagAndItemSchema(Schema): # this class defines a schema for a item to tag relation (1-1)

    message = fields.String()
    item = fields.Nested(PlainItemSchema)
    tag = fields.Nested(PlainTagSchema)


# Deserialization: username, password
# Serialization: username, ID
class UserSchema(Schema):

    username = fields.String(required=True)
    password = fields.String(required=True, load_only=True) # dont return the password in serialization ever, return only user related data
    id = fields.Integer(dump_only=True) # return ID when created

# Deserialization: username, password, email
# Serialization: username, ID
class UserRegisterSchema(UserSchema): # the user register schema uses the same fields of user schema but add an email.
    email = fields.String(required=True)